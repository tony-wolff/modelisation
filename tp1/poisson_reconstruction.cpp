#include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
#include <CGAL/IO/read_points.h>

#include <CGAL/Point_set_3.h>
#include <CGAL/Point_set_3/IO.h>

#include <CGAL/remove_outliers.h>
#include <CGAL/grid_simplify_point_set.h>
#include <CGAL/jet_smooth_point_set.h>
#include <CGAL/jet_estimate_normals.h>
#include <CGAL/mst_orient_normals.h>

#include <CGAL/poisson_surface_reconstruction.h>
#include <CGAL/Advancing_front_surface_reconstruction.h>
#include <CGAL/Scale_space_surface_reconstruction_3.h>
#include <CGAL/Scale_space_reconstruction_3/Jet_smoother.h>
#include <CGAL/Scale_space_reconstruction_3/Advancing_front_mesher.h>

#include <CGAL/Surface_mesh.h>
#include <CGAL/Polygon_mesh_processing/polygon_soup_to_polygon_mesh.h>

#include <cstdlib>
#include <vector>
#include <fstream>

// types
typedef CGAL::Exact_predicates_inexact_constructions_kernel Kernel;
typedef Kernel::FT FT;
typedef Kernel::Point_3 Point_3;
typedef Kernel::Vector_3 Vector_3;
typedef Kernel::Sphere_3 Sphere_3;
typedef CGAL::Point_set_3<Point_3, Vector_3> Point_set;



int main(int argc, char*argv[])
{
  
  const char* input_file =  (argc>1) ? argv[1] : "../data/CQ500-CT-0.xyz";
  
  

  std::vector<Point_3> pnts;// points without normals
  if(!CGAL::IO::read_points(input_file, std::back_inserter(pnts)))
  {
    std::cerr << "Error: cannot read file " << input_file << std::endl;
    return EXIT_FAILURE;
  }
  std::cout << pnts.size()<<" points are read " << std::endl;

  Point_set points;
  for(std::size_t i=0; i< pnts.size(); ++i)
    points.insert(pnts[i]);
  points.add_normal_map();// Poisson requires normal computation 
 
  
  std::cout << "Compute average spacing" << std::endl;
  double spacing = CGAL::compute_average_spacing<CGAL::Sequential_tag> (points, 6);
  
  unsigned int reconstruction_choice= (argc < 3 ? 0 : atoi(argv[2]));

  CGAL::Surface_mesh<Point_3> output_mesh;
  CGAL::Scale_space_surface_reconstruction_3<Kernel> reconstruct
    (points.points().begin(), points.points().end());

  std::string output_file_name ="../data/";
  
  if (reconstruction_choice == 0) // Poisson
  {
    std::cout << "Poisson reconstruction" << std::endl;
    output_file_name += "poisson";
   
    // std::cout << "Jet smooth point set" << std::endl;
    // CGAL::jet_smooth_point_set<CGAL::Sequential_tag>
    //   (points, 24); // Use 24 neighbors

    std::cout << "Estimate normal (Osculatting jets) " << std::endl;
    CGAL::jet_estimate_normals<CGAL::Sequential_tag>
      (points, 24); // Use 24 neighbors
   
    std::cout << "Orient normal (MST)" << std::endl;
    typename Point_set::iterator unoriented_points_begin =
      CGAL::mst_orient_normals(points, 24); // Use 24 neighbors
    points.remove (unoriented_points_begin, points.end());
  
    std::cout << "Reconstruct surface (Poisson)" << std::endl;
    CGAL::poisson_surface_reconstruction_delaunay
      (points.begin(), points.end(),
       points.point_map(), points.normal_map(),
       output_mesh, spacing);
  }
  else if (reconstruction_choice == 1) // Advancing front
  {
    std::cout << "Advancing front reconstruction " << std::endl;
    output_file_name += "advancing_front";
    
    typedef std::array<std::size_t, 3> Facet; // Triple of indices
    std::vector<Facet> facets;

    // The function is called using directly the points raw iterators
    CGAL::advancing_front_surface_reconstruction(points.points().begin(),
                                                 points.points().end(),
                                                 std::back_inserter(facets));
    std::cout << facets.size ()
              << " facet(s) generated by reconstruction." << std::endl;
    // copy points for random access
    std::vector<Point_3> vertices;
    vertices.reserve (points.size());
    std::copy (points.points().begin(), points.points().end(), std::back_inserter (vertices));

    std::cout << "Polygon soup to polygon mesh " << std::endl;
    CGAL::Polygon_mesh_processing::polygon_soup_to_polygon_mesh (vertices, facets, output_mesh);
  // //   std::ofstream f ("out.off");
  // //   f << output_mesh;
  // //   f.close ();
  }
  else if (reconstruction_choice == 2) // Scale space
  {
    std::cout << "Scale space reconstruction " << std::endl;
    output_file_name += "scale_space";
   
    std::cout << "Jet Smoothing " << std::endl;
    // Smooth using 4 iterations of Jet Smoothing
    reconstruct.increase_scale (4, CGAL::Scale_space_reconstruction_3::Jet_smoother<Kernel>());

    std::cout << "Advancing Front mesher " << std::endl;
    // Mesh with the Advancing Front mesher with a maximum facet length of 0.5
    reconstruct.reconstruct_surface (CGAL::Scale_space_reconstruction_3::Advancing_front_mesher<Kernel>(0.5));
  }
  else // Handle error
    {
      std::cerr << "Error: invalid reconstruction id: " << reconstruction_choice << std::endl;
      return EXIT_FAILURE;
    }
  output_file_name += "_reconstruction.off";
  const char* output_file =  (argc>2) ? argv[3] : output_file_name.c_str() ;
  if(reconstruction_choice == 0 || reconstruction_choice == 1) {
    std::ofstream f01 (output_file, std::ios_base::binary);
    CGAL::IO::set_binary_mode (f01);
    CGAL::IO::write_OFF(f01, output_mesh);
    f01.close ();
    }
  else
    {
      std::ofstream f2 (output_file);
      f2 << "OFF" << std::endl << points.size () << " "
	<< reconstruct.number_of_facets() << " 0" << std::endl;
      for (Point_set::Index idx : points)
	f2 << points.point (idx) << std::endl;
      for (const auto& facet : CGAL::make_range (reconstruct.facets_begin(), reconstruct.facets_end()))
	f2 << "3 "<< facet << std::endl;
      f2.close ();
    }
  
  return EXIT_SUCCESS;
}